## 자바

### 1. final 키워드는 무엇이며 어떻게 쓰이는가

여러 컨텍스트에서 단 한 번만 할당될 수 있는 개체를 정의할 때 사용된다
불변성을 유지함으로써 코드 작성 시 발생할 수 있는 버그를 컴파일 타임에 발견할 수 있다

-  변수
   - 원시타입 : 한번 초기화된 변수는 변경할 수 없는 상수값이 된다
   - 객체타입 : 원시타입과 동일하게 한번 쓰인 변수는 변경이 불가능하지만 할당된 객체의 속성은 변경이 가능하다
   - 메서드 인자 : 메서드 안에서 변수값을 변경할 수 없다
   - 멤버 변수 : static 여부에 따라서 초기화 시점이 달라진다
-  메서드
   - 상속받은 클래스에서 오버라이드가 제한된다
-  클래스
   - 상속이 제한된다

### 2. Checked/Unchecked Exception 의 차이와 처리 방법

- Checked Exception
  - 컴파일 타임에 확인
  - 명시적으로 예외처리를 해야함
  - 예외 발생 시 트랜잭션을 롤백하지 않는다
  - Exception을 상속받는 클래스 중 RuntimeException을 제외한 모든 클래스

- Unchecked Exception
  - 런 타임에 확인
  - 명시적인 예외처리를 강제하지 않는다
  - 예외 발생 시 트랜잭션을 롤백한다
  - RuntimeException 을 상속한 클래스

- 처리 방법
  - 복구 : 다른 작업 흐름으로 유도
  - 회피 : 호출한 쪽으로 throw
  - 전환 : 명확한 의미의 예외로 전환 후 throw

### 3. equals()와 hashCode()

- equals : 두 객체의 논리적 동치성(equality)을 비교

  - 주로 값 클래스들이 해당된다(String, Integer...)
  - 재정의 할 때는 핵심 필드를 빠짐없이 비교해야한다

- hashCode : 두 객체의 동일성(identity)을 비교

  - equals를 재정의했다면 hashCode도 반드시 재정의해야 한다

  - equals가 두 객체를 같다고 판단했다면 동일한 hashCode를 반환해야 한다

  - equals가 두 객체를 다르다고 판단했더라도 다른 hashCode를 반환할 필요는 없다

    단, 다른 값을 반환해야 해시테이블의 성능이 좋아진다

## 스프링

### 4. DI 종류와 방법

- 생성자를 통한 주입
  - 대부분의 경우 권장되는 방법
  - 필드를 final로 선언하여 불변하게 만들 수 있음
  - 테스트, 프레임워크 교체가 용이
- 수정자를 통한 주입
  - 선택적으로 DI 가 필요한 경우에만 사용하는 것이 좋음
- 멤버 변수를 통한 주입
  - DI 컨테이너가 필요하기 때문에 가급적 사용하지 않는다

### 5. @Transactional의 기본 동작

- Runtime Exception 발생 시 롤백된다.
- 참여 중인 트랜잭션이 실패하면 전역 롤백된다(기본정책)
- 격리수준, 전파옵션, 롤백 예외 등의 속성을 통해서 동작을 변경할 수 있다

### 6. 스프링 빈은 쓰레드 세이프한가?

스프링 컨테이너가 빈을 싱글톤 레지스트리로 관리하기 때문에 쓰레드 세이프 하다고 착각할 수 있지만 멀티 쓰레드 환경에서 빈의 멤버 변수 또한 공유되어 사용되기 때문에 쓰레드 세이프 하지 않을 수 있다. 다만 빈을 불변하도록 만들어서 쓰레드 세이프하게 사용할 순 있다.

- Constructor Injection을 사용하여 멤버변수 초기화
- Setter 대신 Builder 패턴을 활용

## JPA

### 7. Persistence Context와 Entity 생명주기

인스턴스로 존재하는 엔터티를 관리하고 영속화시키는 영역

- 1차 캐시 저장소 : 엔터티 정보를 보관한다.
- 쿼리 저장소 : 필요한 쿼리를 보관해두고 flush()가 호출될 때 쿼리를 실행한다.
  - EntityManager를 통해서 명시적으로 flush() 실행
  - 트랜잭션 종료(커밋)
  - JPQL Query 가 실행될때 동기화를 위해 flush()가 호출됨
- 생명주기
  - 비영속 상태
  - 영속 상태
  - 준영속 상태
  - 삭제 상태
- 변경감지(Dirty Checking)
  - 엔터티에 대한 참조와 스냅샵을 가지고 flush()가 호출 될 때 비교
  - 영속성 컨텍스트에서 관리하는 엔터티만을 대상으로 진행됨

### 8. n+1문제와 해결방법

일대다, 다대일로 맺어진 양방향 관계에서 Lazy Loading 전략을 사용할 때 n+1개의 쿼리가 실행되는 문제.

- Join Fetch를 사용하여 Eager Loading 할 필드를 지정
- 자식 엔터티 조회에 조건이 걸린다면 FetchMode.SUBSELECT 를 사용
- 2개 이상의 일대다 자식테이블이 있는경우 default_batch_fetch_size 옵션 변경

### 9. 영속성 전이란?

특정 엔터티를 영속 상태로 만들 때 연관된 엔터티들도 함께 영속 상태로 만들 수 있게 해준다.
데이터베이스의 Cascade와 동일한 의미로 사용된다.

- ALL : 모든 변경에 대해 전이
- PERSIST : 저장 시 전이
- MERGE : 병합 시 전이
- REMOVE : 삭제 시 전이
- REFRESH : Entity Manager의 refresh() 호출 시 전이
- DETACH : 부모 엔터티가 detach 되었을때 자식 엔터디도 함께 detach

## ETC

### 10. HATEOAS란?

RESTful API에서 상태 정보를 관리하기 위해 하이퍼미디어를 활용하는 매커니즘을 의미한다.
서버는 클라이언트가 취할 수 있는 요청 URI를 응답에 포함시켜 제공한다.

- 동적으로 생성되는 URI를 사용한다면 클라이언트에서 코드 수정을 최소화 할 수 있다
- 의존되는 요청을 예측할 수 있다